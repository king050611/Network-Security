
---

# 网络安全技术：哈希函数与消息认证码 (完整系统笔记)

这份笔记基于阿伯丁大学的课件《Network Security Technology》，涵盖了从基础定义、核心原理、攻击方式到实际应用的完整知识体系。

---

### 第一模块：哈希函数的基础概念 (Foundations)

**1. 什么是哈希函数？**
*   **定义**：哈希函数 $h$ 是一种数学算法，它接收**任意长度**的输入数据（Message/Pre-image），将其映射为**固定长度**的输出数据（Hash Value / Digest / Fingerprint）。
*   **数学表达**：$h: \{0,1\}^* \rightarrow \{0,1\}^L$（输入是任意二进制串，输出是L位的二进制串）。
*   **核心目的**：提供**数据完整性（Data Integrity）**。它的作用就像给文件按了一个唯一的“指纹”，用于检测数据是否被意外或恶意修改。

**2. 基础操作流程**：
*   **输入**：可以是密码、文件、图片或整个硬盘数据。
*   **处理**：通过特定的数学变换。
*   **输出**：得到一串固定长度的乱码（如 `a1b2...`）。

---

### 第二模块：核心工作原理——迭代结构 (Iterated Structure)

**这是现代哈希函数（如SHA-256）能够处理任意大小文件的核心机制，通常称为 Merkle-Damgård 结构。**

**1. 为什么要用迭代？**
*   数学上的核心组件（压缩函数）只能处理固定大小的数据（如 512 bits）。
*   为了处理**任意长度**的消息，必须采用“切块-循环”的处理模式。

**2. 核心组件与四步流程**：

*   **Step 1: 填充与分块 (Padding & Blocking)**
    *   将无限长的消息 $x$ 切割成若干个固定长度的块：$x_1, x_2, ..., x_m$。
    *   **填充 (Padding)**：如果最后一块填不满，需要补位。**重要安全细节**：填充内容中必须包含**原始消息的长度**，这能防止“长度扩展攻击”。
*   **Step 2: 初始化 (Initialization)**
    *   流水线的第一步需要一个初始值，称为 **IV (Initialization Vector)** 或 $h_0$。这是一个公开的固定常数。
*   **Step 3: 压缩函数 (Compression Function, $f$) —— 引擎**
    *   这是哈希函数的心脏。它接收两个输入：
        1.  **链变量 (Chaining Variable)**：上一轮的输出 ($h_{i-1}$)。
        2.  **消息块 (Message Block)**：当前要处理的数据块 ($x_i$)。
    *   **作用**：将“大的输入”混合并压缩成“小的输出”。
*   **Step 4: 迭代计算 (Iteration)**
    *   **公式**：$h_i = f(x_i, h_{i-1})$
    *   **过程**：像接力跑一样，$h_0 \rightarrow h_1 \rightarrow h_2 ... \rightarrow h_m$。上一轮的输出直接决定下一轮的结果。
    *   **最终结果**：处理完最后一个块后，得到的 $h_m$ 就是最终的哈希值。

**3. 形象理解**：
> 就像炒菜。不管你有多少食材（长消息），你都得分批（分块）下锅。
> 锅里先放底油（IV），加入第一批菜炒熟（压缩），保留锅里的味道，再加入第二批菜一起炒...
> 如果中间任何一批菜换了，最后出锅的味道（Hash值）就会完全不同。

---

### 第三模块：三大安全属性 (Security Properties)

一个安全的加密哈希函数必须具备以下三个特性（难度依次递增）：

**1. 原像抗性 (Pre-image Resistance) / 单向性**
*   **含义**：给定哈希值 $y$，无法算出输入 $x$。
*   **通俗**：不可逆。只能从“猪肉做成香肠”，不能把“香肠还原成猪肉”。
*   **失效后果**：攻击者可以直接从你的密码哈希中还原出明文密码。

**2. 第二原像抗性 (Second Pre-image Resistance)**
*   **含义**：给定一个**特定**的消息 $x$，无法找到另一个 $x'$，使得它们的哈希值相同。
*   **应用**：防止伪造。你签了合同A，攻击者无法伪造一份内容不同但哈希值相同的合同B来顶替。

**3. 抗碰撞性 (Collision Resistance)**
*   **含义**：无法找到**任意**两个不同的消息 $x$ 和 $x'$，使得它们的哈希值相同。
*   **区别**：这里不指定目标，只要找到任意一对“撞车”就算攻击成功。这是最难满足的属性。

---

### 第四模块：雪崩效应与效率 (Avalanche & Efficiency)

**1. 雪崩效应 (Avalanche Effect)**
*   **现象**：输入数据哪怕只改变 **1个比特**（0变1），输出的哈希值应该发生巨大且随机的变化（理想情况下50%的位发生翻转）。
*   **目的**：让攻击者无法通过微调输入来预测输出，混淆输入输出关系。

**2. 效率的考量**
*   **通常**：哈希计算需要非常快（如文件校验）。
*   **特殊（密码学）**：对于**口令存储**，哈希太快是缺点（容易被暴力破解）。因此会使用 **PBKDF2** 或 **scrypt** 等慢速哈希算法，通过增加计算成本来防御字典攻击。

---

### 第五模块：生日悖论与哈希长度 (Birthday Paradox)

这是决定哈希值应该有多长（比如是64位还是256位）的数学依据。

**1. 生日悖论**
*   **直觉**：认为要有人生日相同需要很多人。
*   **事实**：**23人**的房间里，**任意两人**生日相同的概率 > 50%。因为23人能产生 253 对组合。

**2. 生日攻击 (Birthday Attack)**
*   **原理**：攻击哈希的**抗碰撞性**。
*   **结论**：对于 $L$ 位的哈希，找到碰撞只需 $2^{L/2}$ 次尝试，而不是 $2^L$。
*   **警示**：
    *   64位哈希：只需 $2^{32}$ 次运算就能破解（不安全）。
    *   128位哈希（MD5）：只需 $2^{64}$ 次（现代算力下已不安全）。
    *   **推荐**：至少使用 160位 (SHA-1，已淘汰) 或 **256位 (SHA-2, SHA-3)**。

---

### 第六模块：常见算法演进 (Algorithms)

*   **MD5**：128位。**已破碎**。严禁用于数字签名或SSL证书，仍可用于非安全的文件完整性校验。
*   **SHA-1**：160位。**已破碎**。Google曾演示过SHA-1碰撞攻击。Git目前仍在使用它做版本校验，但在逐步迁移。
*   **SHA-2 (如SHA-256)**：目前的主流工业标准。结构类似于SHA-1但更复杂。
*   **SHA-3**：最新标准（2012年选出）。采用与SHA-2完全不同的“海绵结构”，作为备用方案以防SHA-2被破解。

---

### 第七模块：消息认证码 (MACs) & 密钥哈希

单纯的哈希（MDC）只能证明“没被改过”，不能证明“是谁发的”（来源认证）。

**1. MAC (Message Authentication Code)**
*   **核心**：**Keyed Hash**。计算哈希时加入了一个**密钥 (Secret Key)**。
*   **公式**：$MAC = h(Key, Message)$
*   **作用**：同时保证 **完整性** 和 **数据来源认证 (Data Origin Authentication)**。
*   **验证**：只有拥有相同密钥的人（接收者）才能验证真伪。

**2. HMAC (Hash-based MAC)**
*   **定义**：一种构建MAC的标准结构。
*   **构造**：$HMAC_k(x) = h((k \oplus p_1) || h((k \oplus p_2) || x))$。
*   **优势**：通过双重哈希和填充（padding），解决了直接拼接Key带来的安全隐患。

---

### 第八模块：典型应用场景 (Applications)

1.  **文件完整性**：下载软件时对比 Hash 值。
2.  **口令保存**：数据库存 $Hash(Password)$，不存明文。
3.  **数字签名**：
    *   使用**公钥加密**技术。
    *   即：用私钥对文件的**哈希值**进行加密签名。
    *   MAC是用对称密钥（双方共有），数字签名是用非对称密钥（私钥签，公钥验）。
4.  **安全协议**：HTTPS (SSL/TLS) 握手过程中大量使用哈希来验证数据未被篡改。